Типы паттернов:
1. Структурные
2. Порождающие
3. Поведенческие

------------------------------
------------------------------

Singleton(Порождающий паттерн)

Singleton - объект в одном экземпляре. Имеет глобальную точку доступа.

Когда нужен: 
    Необходим объект в одном экземпляре, к которому нужен доступ из разных частей программы

Примеры использования:
    E-Commerce - корзина, карта клиента
    Мультимедиа - экземпляр плеера

------------------------------

Factory Method(Порождающий паттерн)

Factory Method - создает класс, помогающий создавать определенные объекты на основе входных данных

Когда нужен:
    Необходимо множество однотипных объектов, т.е. с одинаковой структурой, но разными данными

Минус:
    Много опций - фабрика разрастётся

------------------------------

Abstract Factory(Порождающий паттерн)

Abstract Factory - интерфейс группирующий другие фабрики, которые логически связанны друг с другом. Простыми словами - это абстракция для фабрики и фабричного метода

Когда нужем:
    Нужна адаптивность в фабрике. 

------------------------------

Prototype(Порождающий паттерн)

Prototype - позволяет копировать объекты, не вдаваясь в особенности их реализации

Когда нужен:
    В случае необходимости изменить структуру объекта и заточить под выполнение определенных задач

------------------------------

Builder(Структурный паттерн)

Builder - используется для создания объектов со сложными состояниями. Может иметь доп. слой абстракций

Когда нужен:
    Если свойства в конструкторе начинают зависить от различных факторов, а также инициализироваться из-за различных условий, что приводит к разрастанию конструктора.

------------------------------

Decorator(Структурный паттерн)

Decorator - используется для добавления объектам новых свойств и методов. По факту, оборачивает исходный объект, чтобы дать ему новый функционал. 

Когда нужен:
    Необходимо добавить функционал, которого ранее не было

------------------------------

Facade(Структурный паттерн)

Facade - Скрывает сложную логику за простым фосадом

Когда нужен:
    Когда нужны различные сложные структуры, которым нужно простое объединение и способ манипуляции

------------------------------

Proxy(Структурный паттерн)

Proxy - вместо реальных объектов представляет объекты-заменители. Перехватывают данные для оригиналов и позволяют совершить операции до того, как данные дойдут до оригинала.

Когда нужен:
    Когда нужна прослойка, выполняющая доп. манипуляции

------------------------------

Adapter(Структурный паттерн)

Adapter - оборачивает несовместимый объект и делает его совместимым, не изменяя оригинальный код

Когда нужен:
    Когда нужно шаблонизировать интерфейсы взаимодействия или сами объекты

------------------------------

Composite(Структурный паттерн)

Composite - позволяет сгруппировать множество объектов в древовидную структуру и работать с этой структурой так, будто это один объект

Когда нужен:
    Необходимо управлять множеством объектов через корневой объект

------------------------------

Bridge(Порождающий паттерн)

Bridge - разделяет один или несколько классов на несколько отдельных иерархий, которые называются абстракция и реализация, что позволяет изменять их вне зависимости друг от друга

Когда нужен:
    Необходимо разделение несоприкасающихся функциональностей в одном классе. Позволяет поместить всю реализацию в классы абстракции и реализации. Абстракция - интерфейс взаимодействия, который делегирует управление в реализацию.

------------------------------

Flyweight(Структурный паттерн)

Flyweight - позволяет вместить большее кол-во определенных объектов в выделенную память.

Когда нужен:
    Нужно сохранить память, поэтому объект, или коллекцию объектов, нужно "кэшировать"

------------------------------

Mediator(Поведенческий паттерн)

Mediator - позволяет уменьшить взаимосвязь классов между собой, вынося межклассовые связи в класс-посредник

Когда нужен:
    Необходимо структуризировать потоки данных между классами и объектами или необходимо переиспользовать компоненты не разбираясь во взаимосвязях между ними

------------------------------

Iterator(Поведенческий паттерн)

Iterator - позволяет последовательно обходить элементы составных объектов, не раскрывая их внутреннее предстваление

Когда нужен:
    Нужен функционал обхода коллекции, но не надо менять коллекцию  

------------------------------

Chain of Responsibility(Поведенческий паттерн)

Chain of Resposibility - позволяет передавать запросы последовательно, по цепочке обработчиков, причем каждый последующий разработчик решает может ли сам обработать запрос, либо его надо передать дальше по цепочке. Если запрос можно обработать, возвращается результат работы обработчика.

Когда нужен:
    Нужно создать цепочку обработки данных.

------------------------------

Strategy(Поведенческий паттерн)

Strategy - определяет схожие алгоритмы и помещает их в отдельные классы, после чего между алгоритмами можно переключаться во время работы программы

Когда нужен:
    При масштабировании приложения, чтобы разбить единый код на модули.

------------------------------

Memento(Поведенческий паттерн)

Memento - сохраняет и восстанавливает предыдущее состояние объекта

Когда нужен:
    При необходимости сохранять состояния объекта.

------------------------------

Template Method(Поведенческий паттерн)

Template Method - определяет базовые шаги исполнения алгоритма и выполнения каждого из этих шагов делегирует на соответствующие методы и подклассы

Когда нужен:
    Необходимы шаблонное выполнение алгоритмов имеющих одинаковый интерфейс взаимодействия, но различную внутреннюю имплементацию

------------------------------

Visitor(Поведенческий паттерн)

Visitor - добавляет новую функциональность к уже существующим классам, причем делает это не изменяя исходный код классов

Когда нужен:
    Необходимо расширить функциональность класса не изменяя первоначальную реализацию

------------------------------

Command(Поведенческий паттерн)

Command - помогает инкапсулировать некоторые действия и необходимые для них данные, что позволяет отделить клиента от получателя. Можно сказать, что превращает запросы в объекты, позволяя передавать их как аргументы в методы

Когда нужен:
    Программа начинает масштабироваться и необходимо грамотно компоновать сходный по функционалу код

------------------------------

Observer(Поведенческий паттерн)

Observer - создает механизм подписки, позволяющий одним объектам следить за изменениями других объектов.

Когда нужен:
    Необходимо отслеживать изменения в объекте и реагировать на него

------------------------------

State(Поведенческий паттерн)

State - позволяет менять объектам менять своё поведение в зависимости от состояния, что со стороны выглядит как включение в работу другого класса.

Когда нужен:
    